//! Implementation of a simple expression parser.

use crate::datamodel::{Data, GlobalDataLock};
use crate::expression_engine::expressions::{
    get_expression_as, Expression, ExpressionArray, ExpressionAssign, ExpressionAssignUndefined, ExpressionConstant,
    ExpressionIndex, ExpressionMemberAccess, ExpressionMethod, ExpressionNot, ExpressionOperator, ExpressionResult,
    ExpressionVariable, Operator,
};
use std::fmt;
use std::fmt::{Debug, Display, Formatter};
use std::ops::Deref;

#[cfg(feature = "Debug")]
use crate::fsm::vec_to_string;
#[cfg(feature = "Debug")]
use log::debug;

/// Numeric types.
#[derive(PartialEq, Debug)]
pub enum NumericToken {
    Integer(i64),
    Double(f64),
}

impl NumericToken {
    pub fn as_double(&self) -> f64 {
        match self {
            NumericToken::Integer(i) => *i as f64,
            NumericToken::Double(d) => *d,
        }
    }
}

/// Token variants, generated by Lexer.
#[derive(PartialEq, Debug)]
pub enum Token {
    /// Some constant number. Integer or float.
    Number(NumericToken),
    /// An identifier
    Identifier(String),
    /// Some constant string expression
    TString(String),
    /// A constant boolean expression.
    Boolean(bool),
    /// Some operator
    Operator(Operator),
    /// Some bracket
    Bracket(char),
    /// A - none whitespace, none bracket - separator
    Separator(char),
    /// a Null value
    Null(),
    /// Indicates a lexer error.
    Error(String),
    /// Indicates the end of the expression.
    EOE,
}

impl Display for Token {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        Debug::fmt(self, f)
    }
}

/// Lexer for Expressions. \
/// Generates tokens from text.
pub struct ExpressionLexer {
    text: Vec<char>,
    pos: usize,
    buffer: String,
}

impl ExpressionLexer {
    pub fn new(text: String) -> Self {
        let mut chars = Vec::with_capacity(text.len());
        for c in text.chars() {
            chars.push(c);
        }
        ExpressionLexer {
            text: chars,
            pos: 0,
            buffer: String::with_capacity(100),
        }
    }

    fn is_stop(c: char) -> bool {
        Self::is_whitespace(c)
            || match c {
            '\0' | '.' | '!' | ',' | '\\' | ';' |
            // Operators
            '-' | '+' | '/' | ':' | '*' |
            '<' | '>' | '=' | '%' | '?' |
            // Brackets
            '[' | ']' | '(' | ')' | '{' | '}' |
            // String
            '"' | '\'' => { true }
            _ => { false }

        }
    }

    fn is_string_delimiter(c: char) -> bool {
        matches!(c, '\'' | '"')
    }

    pub fn next_char(&mut self) -> char {
        if self.pos < self.text.len() {
            let c = self.text[self.pos];
            self.pos += 1;
            c
        } else {
            '\0'
        }
    }

    pub fn push_back(&mut self) {
        if self.pos > 0 {
            self.pos -= 1;
        }
    }

    /// Read a String.\
    /// delimiter - The delimiter\
    /// Escape sequences see String state-chart on JSON.org.
    fn read_string(&mut self, delimiter: char) -> Token {
        let mut escape = false;
        let mut c;
        loop {
            c = self.next_char();
            if c == '\0' {
                return Token::Error("Missing string delimiter".to_string());
            } else if escape {
                match c {
                    '"' | '\\' | '/' => {}
                    'b' => {
                        c = '\x08';
                    }
                    'f' => {
                        c = '\x0c';
                    }
                    'n' => {
                        c = '\n';
                    }
                    'r' => {
                        c = '\r';
                    }
                    't' => {
                        c = '\t';
                    }
                    'u' => {
                        // 4 hex digits
                        let mut codepoint = String::with_capacity(4);
                        for _i in 0..4 {
                            let c = self.next_char();
                            if Self::is_digit(c) {
                                codepoint.push(c);
                            } else {
                                return Token::Error("Illegal \\u sequence in String".to_string());
                            }
                        }
                        let cp = u32::from_str_radix(codepoint.as_str(), 16);
                        match cp {
                            Ok(cpv) => match char::from_u32(cpv) {
                                None => {
                                    return Token::Error(format!(
                                        "Illegal codepoint {} in \\u sequence {}",
                                        cpv, codepoint
                                    ));
                                }
                                Some(cpc) => {
                                    c = cpc;
                                }
                            },
                            Err(_err) => {
                                return Token::Error(format!("Illegal \\u sequence {}", codepoint));
                            }
                        }
                    }
                    _ => {
                        return Token::Error("Illegal escape sequence in String".to_string());
                    }
                }
                escape = false;
            } else if c == '\\' {
                escape = true;
                continue;
            } else if c == delimiter {
                return Token::TString(self.buffer.clone());
            }
            self.buffer.push(c);
        }
    }

    /// Read (possible combined) operators
    fn read_operator(&mut self, first: char) -> Token {
        Token::Operator(match first {
            '-' => Operator::Minus,
            '+' => Operator::Plus,
            '*' => Operator::Multiply,
            ':' | '/' => Operator::Divide,
            '%' => Operator::Modulus,
            _ => {
                let second = self.next_char();
                if second == '=' {
                    match first {
                        '?' => Operator::AssignUndefined,
                        '<' => Operator::LessEqual,
                        '>' => Operator::GreaterEqual,
                        '=' => Operator::Equal,
                        '!' => Operator::NotEqual,
                        _ => {
                            // This method shall not be called with other chars.
                            return Token::Error("Internal Error".to_string());
                        }
                    }
                } else {
                    self.push_back();
                    match first {
                        '<' => Operator::Less,
                        '>' => Operator::Greater,
                        '=' => Operator::Assign,
                        '!' => Operator::Not,
                        _ => {
                            // This method shall not be called with other chars.
                            return Token::Error("Internal Error".to_string());
                        }
                    }
                }
            }
        })
    }

    /// Read a JSON Number (see state chart at JSON.org).
    /// c - The starting character.
    fn read_number(&mut self, mut c: char) -> Token {
        // States:
        // 0: Init
        // 1: In fix-point part
        // 2: In fraction part
        // 3: Just after "E"
        // 4: In exponent
        // 5: On starting "-"
        // 6: On "-" or "+" after "E"

        let mut state = 0u8;
        loop {
            if c == '.' {
                match state {
                    0 | 1 | 5 => {
                        state = 2u8;
                    }
                    _ => {
                        self.push_back();
                        break;
                    }
                }
            } else if Self::is_digit(c) {
                match state {
                    0 | 5 => {
                        state = 1u8;
                    }
                    3 | 6 => {
                        state = 4u8;
                    }
                    _ => {}
                }
            } else if c == '+' {
                // According to JSON only legal just after the "E".
                match state {
                    0 => {
                        return Token::Operator(Operator::Plus);
                    }
                    5 => {
                        self.push_back();
                        return Token::Operator(Operator::Minus);
                    }
                    3 => {
                        state = 6u8;
                    }
                    _ => {
                        self.push_back();
                        break;
                    }
                }
            } else if c == '-' {
                // According to JSON only legal at start or just after the "E".
                match state {
                    0 => {
                        state = 5u8;
                    }
                    3 => {
                        state = 6u8;
                    }
                    5 => {
                        self.push_back();
                        return Token::Operator(Operator::Minus);
                    }
                    _ => {
                        self.push_back();
                        break;
                    }
                }
            } else if c == 'E' || c == 'e' {
                match state {
                    1 | 2 => {
                        state = 3;
                    }
                    5 => {
                        return Token::Operator(Operator::Minus);
                    }
                    _ => {
                        self.push_back();
                        break;
                    }
                }
            } else {
                if c != '\0' {
                    self.push_back();
                }
                break;
            }
            self.buffer.push(c);
            c = self.next_char();
        }
        match state {
            1 => {
                let r = self.buffer.parse::<i64>();
                match r {
                    Ok(v) => Token::Number(NumericToken::Integer(v)),
                    Err(err) => Token::Error(err.to_string()),
                }
            }
            2 | 4 => {
                if self.buffer.len() == 1 {
                    // Special case '.'
                    Token::Separator('.')
                } else {
                    let r = self.buffer.parse::<f64>();
                    match r {
                        Ok(v) => Token::Number(NumericToken::Double(v)),
                        Err(err) => Token::Error(err.to_string()),
                    }
                }
            }
            3 | 6 => Token::Error("missing exponent in number".to_string()),
            5 => Token::Operator(Operator::Minus),
            _ => Token::Error("internal error".to_string()),
        }
    }

    /// A much, much simpler replacement for char.is_digit(10).
    #[inline(always)]
    fn is_digit(c: char) -> bool {
        c.is_ascii_digit()
    }

    /// Check for a JSON whitespace.
    #[inline(always)]
    fn is_whitespace(c: char) -> bool {
        matches!(c, ' ' | '\n' | '\r' | '\t')
    }

    /// Parse and return the next token.
    pub fn next_token(&mut self) -> Token {
        // at start of new symbol, eat all spaces
        self.eat_space();
        self.buffer.clear();
        let mut c = self.next_char();

        // Start chars for a legal Number ('+' and "." NOT in JSON):
        if Self::is_digit(c) || c == '-' || c == '+' || c == '.' {
            return self.read_number(c);
        }
        loop {
            if Self::is_stop(c) {
                if self.buffer.is_empty() {
                    if Self::is_string_delimiter(c) {
                        // At start of string
                        return self.read_string(c);
                    } else {
                        // return the current stop as symbol
                        match c {
                            '\0' => {
                                return Token::EOE;
                            }
                            '?' | '+' | '-' | '*' | '<' | '>' | '=' | '%' | '/' | ':' | '!' => {
                                return self.read_operator(c);
                            }
                            '{' | '}' | '(' | ')' | '[' | ']' => {
                                return Token::Bracket(c);
                            }
                            _ => {
                                return Token::Separator(c);
                            }
                        }
                    }
                } else if c != '\0' {
                    // handle this the next call
                    self.push_back();
                }
                return match self.buffer.as_str() {
                    "true" => Token::Boolean(true),
                    "false" => Token::Boolean(false),
                    "null" => Token::Null(),
                    _ => Token::Identifier(self.buffer.clone()),
                };
            }
            // append until stop is found.
            self.buffer.push(c);
            c = self.next_char();
        }
    }

    /// Return the next token as a number, otherwise return Error.
    pub fn next_number(&mut self) -> Result<NumericToken, String> {
        let t = self.next_token();
        match t {
            Token::Number(e) => Ok(e),
            Token::Error(s) => Err(s),
            _ => Err("".to_string()),
        }
    }

    /// Return the next token to an Identifier, otherwise return Error.
    pub fn next_name(&mut self) -> Result<String, String> {
        let t = self.next_token();
        match t {
            Token::Identifier(e) => Ok(e),
            x => Err(format!("Unexpected token {}", x)),
        }
    }

    /// Checks if the lexer has at least one token remaining.
    pub fn has_next(&self) -> bool {
        self.pos < self.text.len()
    }

    /// Easts whitespaces.
    fn eat_space(&mut self) {
        while self.has_next() && Self::is_whitespace(self.text[self.pos]) {
            self.pos += 1;
        }
    }
}

/// Static tool struct to process expressions.
pub struct ExpressionParser {}

/// Internal item for the parser stack.
enum ExpressionParserItem {
    SToken(Token),
    SExpression(Box<dyn Expression>),
}

impl Display for ExpressionParserItem {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        match self {
            ExpressionParserItem::SToken(t) => Debug::fmt(t, f),
            ExpressionParserItem::SExpression(e) => Debug::fmt(e, f),
        }
    }
}

impl ExpressionParser {
    /// Parse a argument list, stops at the matching ")"
    fn parse_argument_list(lexer: &mut ExpressionLexer, stop: char) -> Result<Vec<Box<dyn Expression>>, String> {
        let mut r = Vec::new();
        loop {
            let (stopc, expression) = Self::parse_sub_expression(lexer, &[',', stop])?;
            match expression {
                None => {
                    if r.is_empty() {
                        // Special case: empty argument list
                        break;
                    } else {
                        return Err("Error in argument list".to_string());
                    }
                }
                Some(e) => {
                    r.push(e);
                }
            }
            if stopc == stop {
                break;
            }
            if stopc == '\0' {
                return Err(format!("Missing '{}'", stop));
            }
        }
        Ok(r)
    }

    /// Parse an expression, returning a re-usable expression.
    pub fn parse(text: String) -> Result<Box<dyn Expression>, String> {
        let mut lexer = ExpressionLexer::new(text);
        let (_, expression) = Self::parse_sub_expression(&mut lexer, &['\0'])?;
        match expression {
            None => Err("Failed to parse".to_string()),
            Some(e) => Ok(e),
        }
    }

    /// Parses and executes an expression.\
    /// If possible, please use "parse" and re-use the parsed expressions.
    pub fn execute(source: String, context: &mut GlobalDataLock) -> ExpressionResult {
        #[cfg(feature = "Debug")]
        debug!("ExpressionParser::execute: {}", source);
        let parser_result = Self::parse(source);
        let r = match parser_result {
            Ok(v) => v.execute(context, false),
            Err(err) => ExpressionResult::Err(err),
        };
        #[cfg(feature = "Debug")]
        debug!("ExpressionParser::execute: result {:?}", r);
        r
    }

    fn parse_sub_expression(
        lexer: &mut ExpressionLexer,
        stops: &[char],
    ) -> Result<(char, Option<Box<dyn Expression>>), String> {
        // Translate the lexer tokens and put them to the stack. Resolve method calls and sub-expressions.
        // The result will be a stack sequence of identifier / operators / expressions.
        // All remaining "Identifier" are variables.
        let mut stack: Vec<ExpressionParserItem> = Vec::new();
        let mut stop = '\0';
        loop {
            let t = lexer.next_token();
            match &t {
                Token::EOE => {
                    break;
                }
                Token::Null() => {
                    stack.push(ExpressionParserItem::SExpression(Box::new(
                        ExpressionConstant::new(Data::Null()),
                    )));
                }
                Token::TString(text) => {
                    stack.push(ExpressionParserItem::SExpression(Box::new(
                        ExpressionConstant::new(Data::String(text.clone())),
                    )));
                }
                Token::Boolean(v) => {
                    stack.push(ExpressionParserItem::SExpression(Box::new(
                        ExpressionConstant::new(Data::Boolean(*v)),
                    )));
                }
                Token::Number(v) => {
                    stack.push(ExpressionParserItem::SExpression(Box::new(
                        ExpressionConstant::new(match v {
                            NumericToken::Integer(i) => Data::Integer(*i),
                            NumericToken::Double(i) => Data::Double(*i),
                        }),
                    )));
                }
                Token::Identifier(_) => {
                    stack.push(ExpressionParserItem::SToken(t));
                }
                Token::Operator(_) => {
                    stack.push(ExpressionParserItem::SToken(t));
                }
                Token::Bracket(br) => match br {
                    '(' => {
                        let si = stack.pop();
                        match si {
                            None => {
                                let (_, se) = Self::parse_sub_expression(lexer, &[')'])?;
                                match se {
                                    None => {}
                                    Some(sev) => {
                                        stack.push(ExpressionParserItem::SExpression(sev));
                                    }
                                }
                            }
                            Some(si) => match si {
                                ExpressionParserItem::SToken(token) => match token {
                                    Token::Null()
                                    | Token::Separator(_)
                                    | Token::Bracket(_)
                                    | Token::Boolean(_)
                                    | Token::TString(_)
                                    | Token::Number(_) => {
                                        return Result::Err(format!("Unexpected '{}'", br));
                                    }
                                    Token::Identifier(id) => {
                                        let v = Self::parse_argument_list(lexer, ')')?;
                                        let x = Box::new(ExpressionMethod::new(id.as_str(), v));
                                        stack.push(ExpressionParserItem::SExpression(x));
                                    }
                                    Token::Operator(_) => {
                                        stack.push(ExpressionParserItem::SToken(token));
                                        let (_, se) = Self::parse_sub_expression(lexer, &[')'])?;
                                        match se {
                                            None => {}
                                            Some(sev) => {
                                                stack.push(ExpressionParserItem::SExpression(sev));
                                            }
                                        }
                                    }
                                    Token::Error(_) => {}
                                    Token::EOE => {}
                                },
                                ExpressionParserItem::SExpression(_) => {
                                    return Result::Err(format!("Unexpected '{}'", br));
                                }
                            },
                        }
                    }
                    '[' => {
                        let si = stack.pop();
                        match si {
                            None => {
                                let v = Self::parse_argument_list(lexer, ']')?;
                                let x = Box::new(ExpressionArray::new(v));
                                stack.push(ExpressionParserItem::SExpression(x));
                            }
                            Some(si) => match si {
                                ExpressionParserItem::SToken(token) => match token {
                                    Token::Null()
                                    | Token::Separator(_)
                                    | Token::Bracket(_)
                                    | Token::Boolean(_)
                                    | Token::TString(_)
                                    | Token::Number(_) => {
                                        return Result::Err(format!("Unexpected '{}'", br));
                                    }
                                    Token::Identifier(id) => {
                                        let mut v = Self::parse_argument_list(lexer, ']')?;
                                        if v.len() != 1 {
                                            return Result::Err(
                                                "index operator '[]' allows only one argument".to_string(),
                                            );
                                        }
                                        let x = Box::new(ExpressionIndex::new(
                                            Box::new(ExpressionVariable::new(id.as_str())),
                                            v.remove(0),
                                        ));
                                        stack.push(ExpressionParserItem::SExpression(x));
                                    }
                                    Token::Operator(_) => {
                                        // Put token back on stack.
                                        stack.push(ExpressionParserItem::SToken(token));
                                        let v = Self::parse_argument_list(lexer, ']')?;
                                        let x = Box::new(ExpressionArray::new(v));
                                        stack.push(ExpressionParserItem::SExpression(x));
                                    }
                                    _ => {
                                        return Result::Err(format!("Internal Error at '{}'", br));
                                    }
                                },
                                ExpressionParserItem::SExpression(_) => {
                                    return Result::Err(format!("Unexpected '{}'", br));
                                }
                            },
                        }
                    }
                    _ => {
                        if stops.contains(br) {
                            stop = *br;
                            break;
                        } else {
                            return Result::Err(format!("Unexpected '{}'", br));
                        }
                    }
                },
                Token::Separator(sep) => {
                    if stops.contains(sep) {
                        stop = *sep;
                        break;
                    } else if *sep == '.' {
                        stack.push(ExpressionParserItem::SToken(Token::Separator('.')));
                    }
                }
                Token::Error(err) => {
                    return Result::Err(err.clone());
                }
            }
        }
        let expression = Self::stack_to_expression(&mut stack)?;
        Ok((stop, expression))
    }

    /// Removes both neighbours of the item at the index, then call the function with the
    /// neighbours and replace the item at the index with the result.\
    /// If the operation fails, all items (at index and neighbours) are removed.\
    /// Neighbours must be ExpressionParserItem::SExpression.
    fn fold_stack_at<F>(stack: &mut Vec<ExpressionParserItem>, idx: usize, f: F) -> bool
    where
        F: Fn(Box<dyn Expression>, Box<dyn Expression>) -> Result<Box<dyn Expression>, String>,
    {
        if idx > 0 && (idx + 1) < stack.len() {
            let right = stack.remove(idx + 1);
            stack.remove(idx);
            let left = stack.remove(idx - 1);

            if let ExpressionParserItem::SExpression(re) = right {
                if let ExpressionParserItem::SExpression(le) = left {
                    match f(le, re) {
                        Ok(expression) => {
                            stack.insert(idx - 1, ExpressionParserItem::SExpression(expression));
                            return true;
                        }
                        Err(_err) => return false,
                    }
                }
            }
        }
        false
    }

    /// Tries to create an expression from the current contents of the parser-stack.
    fn stack_to_expression(stack: &mut Vec<ExpressionParserItem>) -> Result<Option<Box<dyn Expression>>, String> {
        #[cfg(feature = "Debug")]
        debug!(
            "ExpressionParser.stack_to_expression: stack={:?}",
            vec_to_string(stack)
        );
        if stack.is_empty() {
            return Result::Ok(None);
        }
        // Handle operators and identifier
        let mut best_idx = 0usize;
        let mut best_idx_prio = 0xffu8;
        // Fold Methods on variables. Currently, this will not work with the logic below.
        let mut si = 0;
        while si < stack.len() {
            match &stack[si] {
                ExpressionParserItem::SToken(token) => match token {
                    Token::Identifier(identifier) => {
                        let ex = Box::new(ExpressionVariable::new(identifier));
                        stack[si] = ExpressionParserItem::SExpression(ex);
                    }
                    Token::Separator('.') => {
                        if 2 < best_idx_prio {
                            best_idx = si;
                            best_idx_prio = 2;
                        }
                    }
                    Token::Operator(operator) => {
                        let prio = match operator {
                            Operator::Not => 3u8,
                            Operator::Multiply => 5,
                            Operator::Divide => 5,
                            Operator::Modulus => 5,
                            Operator::Plus => 6,
                            Operator::Minus => 6,
                            Operator::Less => 9,
                            Operator::LessEqual => 9,
                            Operator::Greater => 9,
                            Operator::GreaterEqual => 9,
                            Operator::Equal => 10,
                            Operator::NotEqual => 10,
                            Operator::Assign => 16,
                            Operator::AssignUndefined => 16,
                        };
                        if prio < best_idx_prio {
                            best_idx = si;
                            best_idx_prio = prio;
                        }
                    }
                    _ => {
                        panic!("Internal error")
                    }
                },
                ExpressionParserItem::SExpression(_) => {}
            }
            si += 1;
        }
        if best_idx_prio < 0xffu8 {
            let mut op = None;
            let si = stack.get(best_idx).unwrap();
            if let ExpressionParserItem::SToken(Token::Operator(op_t)) = si {
                op = Some(op_t.clone());
            }
            if let Some(op) = op {
                match op.clone() {
                    Operator::Divide
                    | Operator::Plus
                    | Operator::Minus
                    | Operator::Less
                    | Operator::LessEqual
                    | Operator::Greater
                    | Operator::GreaterEqual
                    | Operator::Equal
                    | Operator::NotEqual
                    | Operator::Modulus
                    | Operator::Multiply => {
                        if Self::fold_stack_at(
                            stack,
                            best_idx,
                            |le: Box<dyn Expression>, re: Box<dyn Expression>| -> Result<Box<dyn Expression>, String> {
                                Ok(Box::new(ExpressionOperator::new(op.clone(), le, re)))
                            },
                        ) {
                            return Self::stack_to_expression(stack);
                        }
                    }
                    Operator::AssignUndefined => {
                        if Self::fold_stack_at(
                            stack,
                            best_idx,
                            |le: Box<dyn Expression>, re: Box<dyn Expression>| -> Result<Box<dyn Expression>, String> {
                                Ok(Box::new(ExpressionAssignUndefined::new(le, re)))
                            },
                        ) {
                            return Self::stack_to_expression(stack);
                        }
                    }
                    Operator::Assign => {
                        if Self::fold_stack_at(
                            stack,
                            best_idx,
                            |le: Box<dyn Expression>, re: Box<dyn Expression>| -> Result<Box<dyn Expression>, String> {
                                Ok(Box::new(ExpressionAssign::new(le, re)))
                            },
                        ) {
                            return Self::stack_to_expression(stack);
                        }
                    }
                    Operator::Not => {
                        if (best_idx + 1) < stack.len() {
                            stack.remove(best_idx);
                            let right = stack.remove(best_idx);
                            if let ExpressionParserItem::SExpression(re) = right {
                                stack.insert(
                                    best_idx,
                                    ExpressionParserItem::SExpression(Box::new(ExpressionNot::new(re))),
                                );
                                return Self::stack_to_expression(stack);
                            }
                        }
                    }
                }
                return Err(format!("Failed to parse at operator '{:?}'", op));
            } else if let ExpressionParserItem::SToken(Token::Separator(sep_char)) = *si {
                if best_idx > 0
                    && (best_idx + 1) < stack.len()
                    && Self::fold_stack_at(
                        stack,
                        best_idx,
                        |le: Box<dyn Expression>, re: Box<dyn Expression>| -> Result<Box<dyn Expression>, String> {
                            if let Some(variable) = get_expression_as::<ExpressionVariable>(re.deref()) {
                                return Ok(Box::new(ExpressionMemberAccess::new(
                                    le,
                                    variable.name.clone(),
                                )));
                            }
                            if let Some(method) = get_expression_as::<ExpressionMethod>(re.deref()) {
                                let mut method_copy = method.get_copy();
                                method_copy.arguments.insert(0, le);
                                Ok(method_copy)
                            } else {
                                Err("No Field/Method on right side of '.'".to_string())
                            }
                        },
                    )
                {
                    return Self::stack_to_expression(stack);
                } else {
                    return Err(format!("Failed to parse at '{}'", sep_char));
                }
            }
        } else {
            let x = stack.remove(0);
            if let ExpressionParserItem::SExpression(ex) = x {
                // No operator? Return first one.
                return Ok(Some(ex));
            } else {
                return Err(format!("Failed to parse at '{}'", x));
            }
        }
        Err("Failed to parse".to_string())
    }
}

#[cfg(test)]
mod tests {
    use crate::datamodel::{create_data_arc, create_global_data_arc, Data, GlobalDataArc};
    use crate::expression_engine::datamodel::RFsmExpressionDatamodel;
    use crate::expression_engine::expressions::ExpressionResult;
    use crate::expression_engine::parser::{ExpressionLexer, ExpressionParser, NumericToken, Operator, Token};
    use crate::fsm::GlobalData;
    use std::collections::HashMap;
    use std::ops::Deref;
    use std::sync::Mutex;

    #[test]
    fn can_parse_numbers() {
        let mut l = ExpressionLexer::new("123 345.123 +456 -123 1e10 1.0e10 0x123".to_string());

        let n1 = l.next_number();
        println!("N1: {:?}", n1);
        assert!(n1.is_ok());
        assert_eq!(n1.unwrap().as_double(), 123f64);

        let n2 = l.next_number();
        println!("N2: {:?}", n2);
        assert!(n2.is_ok());
        assert_eq!(n2.unwrap().as_double(), 345.123f64);

        // Leading "+" are not allowed in JSON. We will get this as operator.
        let n3 = l.next_token();
        println!("N3: {:?}", n3);
        assert_eq!(n3, Token::Operator(Operator::Plus));

        let n3b = l.next_token();
        println!("N3b: {:?}", n3b);
        assert_eq!(n3b, Token::Number(NumericToken::Integer(456)));

        let n4 = l.next_number();
        println!("N4: {:?}", n4);
        assert!(n4.is_ok());
        assert_eq!(n4.unwrap().as_double(), -123f64);

        let n5 = l.next_number();
        println!("N5: {:?}", n5);
        assert!(n5.is_ok());
        assert_eq!(n5.unwrap().as_double(), 1e10f64);

        let n6 = l.next_number();
        println!("N6: {:?}", n6);
        assert!(n6.is_ok());
        assert_eq!(n6.unwrap().as_double(), 1e10f64);

        // Sorry, no hex in json
        let n7 = l.next_token();
        println!("N7: {:?}", n7);
        assert!(matches!(n7, Token::Number(NumericToken::Integer(0))));

        let n8 = l.next_token();
        println!("N8: {:?}", n8);
        assert_eq!(n8, Token::Identifier("x123".to_string()));

        let n9 = l.next_token();
        println!("N9: {:?}", n9);
        assert_eq!(n9, Token::EOE);
    }

    #[test]
    fn lexer_can_parse_names() {
        let mut l = ExpressionLexer::new(" abc efg.xyz  . ZzZ".to_string());

        let n1 = l.next_name();
        println!("N1: {:?}", n1);
        assert!(n1.is_ok());
        assert_eq!(n1.unwrap(), "abc");

        let n2 = l.next_name();
        println!("N2: {:?}", n2);
        assert!(n2.is_ok());
        assert_eq!(n2.unwrap(), "efg");

        let n3 = l.next_token();
        println!("N3: {:?}", n3);
        if let Token::Separator(d) = n3 {
            assert_eq!(d, '.');
        } else {
            assert!(false);
        }

        let n4 = l.next_name();
        println!("N4: {:?}", n4);
        assert!(n4.is_ok());
        assert_eq!(n4.unwrap(), "xyz");

        let n5 = l.next_token();
        println!("N5: {:?}", n5);
        if let Token::Separator(d) = n5 {
            assert_eq!(d, '.');
        } else {
            assert!(false);
        }

        let n6 = l.next_name();
        println!("N6: {:?}", n6);
        assert!(n6.is_ok());
        assert_eq!(n6.unwrap(), "ZzZ");
    }

    #[test]
    fn lexer_can_parse_strings() {
        let mut l = ExpressionLexer::new(" \"123.2\" 'abc\\f' 'xx\\u0008xx'".to_string());

        let n1 = l.next_token();
        println!("N1: {:?}", n1);
        assert_eq!(n1, Token::TString("123.2".to_string()));

        let n2 = l.next_token();
        println!("N2: {:?}", n2);
        assert_eq!(n2, Token::TString("abc\x0c".to_string()));

        let n3 = l.next_token();
        println!("N3: {:?}", n3);
        assert_eq!(n3, Token::TString("xx\x08xx".to_string()));

        let n4 = l.next_token();
        println!("N4: {:?}", n4);
        assert_eq!(n4, Token::EOE);
    }

    #[test]
    fn lexer_can_parse_boolean() {
        let mut l = ExpressionLexer::new(" true false 'true' TRUE".to_string());

        let n1 = l.next_token();
        println!("N1: {:?}", n1);
        assert_eq!(n1, Token::Boolean(true));

        let n2 = l.next_token();
        println!("N2: {:?}", n2);
        assert_eq!(n2, Token::Boolean(false));

        // Check that a string "true" is still a string.
        let n3 = l.next_token();
        println!("N3: {:?}", n3);
        assert_eq!(n3, Token::TString("true".to_string()));

        // Check that a true is case sensitive.
        let n4 = l.next_token();
        println!("N4: {:?}", n4);
        assert_eq!(n4, Token::Identifier("TRUE".to_string()));

        let n4 = l.next_token();
        println!("N4: {:?}", n4);
        assert_eq!(n4, Token::EOE);
    }

    #[test]
    fn lexer_can_parse_null() {
        let mut l = ExpressionLexer::new(" null 'null'".to_string());

        // Check that null is parsed.
        let n1 = l.next_token();
        println!("N1: {:?}", n1);
        assert_eq!(n1, Token::Null());

        // Check that "null" as string is still a string.
        let n2 = l.next_token();
        println!("N2: {:?}", n2);
        assert_eq!(n2, Token::TString("null".to_string()));

        let n3 = l.next_token();
        println!("N3: {:?}", n3);
        assert_eq!(n3, Token::EOE);
    }

    #[test]
    fn lexer_can_parse_operators() {
        let mut l = ExpressionLexer::new("=<>!+-*/:% <= >= != ==".to_string());

        let n = l.next_token();
        print!("{:?}", n);
        assert_eq!(n, Token::Operator(Operator::Assign));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::Less));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::Greater));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::Not));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::Plus));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::Minus));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::Multiply));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::Divide));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::Divide));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::Modulus));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::LessEqual));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::GreaterEqual));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::NotEqual));

        let n = l.next_token();
        print!(" {:?}", n);
        assert_eq!(n, Token::Operator(Operator::Equal));

        let n = l.next_token();
        println!(" {:?}", n);
        assert_eq!(n, Token::EOE);
    }

    #[test]
    fn parser_can_parse_a_simple_expression_without_identifiers() {
        let data = RFsmExpressionDatamodel::new(create_global_data_arc());

        let r = ExpressionParser::parse("12 * 3.4".to_string()).unwrap();
        print!("Parsed: {:?}", r);
        let result_data = r.execute(&mut data.global_data.lock().unwrap(), true);
        println!(" => {:?}", result_data);
        assert!(
            result_data.eq(&ExpressionResult::Ok(create_data_arc(Data::Double(
                12f64 * 3.4f64
            ))))
        );

        let r = ExpressionParser::parse("(12 * 2)".to_string()).unwrap();
        print!("Parsed: {:?}", r);
        let result_data = r.execute(&mut data.global_data.lock().unwrap(), true);
        println!(" => {:?}", result_data);
        assert!(result_data.eq(&ExpressionResult::Ok(create_data_arc(Data::Integer(24)))));

        let r = ExpressionParser::parse("(1 * 2) + (12 * 2)".to_string()).unwrap();
        print!("Parsed: {:?}", r);
        let result_data = r.execute(&mut data.global_data.lock().unwrap(), true);
        println!(" => {:?}", result_data);
        assert!(result_data.eq(&ExpressionResult::Ok(create_data_arc(Data::Integer(26)))));
    }

    #[test]
    fn expressions_prioritize_multiplication_division_operations() {
        let data = RFsmExpressionDatamodel::new(GlobalDataArc::new(Mutex::from(GlobalData::new())));

        let r = ExpressionParser::parse("12 + 2 * 4".to_string()).unwrap();
        print!("Parsed: {:?}", r);
        let result_data = r.execute(&mut data.global_data.lock().unwrap(), true);
        println!(" => {:?}", result_data);
        assert!(
            result_data.eq(&ExpressionResult::Ok(create_data_arc(Data::Integer(
                12 + (2 * 4)
            ))))
        );

        // Check that forced "()" work
        let r = ExpressionParser::parse("(12 + 2) * 4".to_string()).unwrap();
        print!("Parsed: {:?}", r);
        let result_data = r.execute(&mut data.global_data.lock().unwrap(), true);
        println!(" => {:?}", result_data);
        assert!(
            result_data.eq(&ExpressionResult::Ok(create_data_arc(Data::Integer(
                (12 + 2) * 4
            ))))
        );
    }

    #[test]
    fn can_parse_methods() {
        // let mut data = GlobalData::new();

        let r = ExpressionParser::parse("method(1,2,3,4)".to_string()).unwrap();
        println!("Parsed: {:?}", r);
    }

    #[test]
    fn can_parse_members() {
        let r1 = ExpressionParser::parse("A.b".to_string()).unwrap();
        println!("Parsed: {:?}", r1);

        let r2 = ExpressionParser::parse("A.b.c".to_string()).unwrap();
        println!("Parsed: {:?}", r2);

        let data = RFsmExpressionDatamodel::new(create_global_data_arc());
        let mut hs1 = HashMap::new();
        let mut hs2 = HashMap::new();
        hs2.insert(
            "c".to_string(),
            create_data_arc(Data::String("hello".to_string())),
        );
        hs1.insert("b".to_string(), create_data_arc(Data::Map(hs2)));

        data.global_data
            .lock()
            .unwrap()
            .data
            .set_undefined("A".to_string(), Data::Map(hs1));
        let rs1 = r1.execute(&mut data.global_data.lock().unwrap(), true);
        println!("==> {:?}", rs1);
        assert!(if let ExpressionResult::Ok(_x) = rs1 {
            true
        } else {
            false
        });

        let rs2 = r2.execute(&mut data.global_data.lock().unwrap(), true);
        println!("==> {:?}", rs2);
        assert_eq!(
            rs2,
            ExpressionResult::Ok(create_data_arc(Data::String("hello".to_string())))
        )
    }

    #[test]
    fn can_parse_assignment() {
        let r1 = ExpressionParser::parse("A=2*6".to_string()).unwrap();
        println!("Parsed: {:?}", r1);

        let data = RFsmExpressionDatamodel::new(create_global_data_arc());
        // data.values.insert( "A".to_string(), Data::Integer(1));

        let rs1 = r1.execute(&mut data.global_data.lock().unwrap(), true);
        println!("==> {:?}", rs1);
        assert_eq!(
            rs1,
            ExpressionResult::Ok(create_data_arc(Data::Integer(12)))
        );
        assert_eq!(
            data.global_data
                .lock()
                .unwrap()
                .data
                .get(&"A".to_string())
                .unwrap()
                .lock()
                .unwrap()
                .deref(),
            &Data::Integer(12)
        );
    }
}
